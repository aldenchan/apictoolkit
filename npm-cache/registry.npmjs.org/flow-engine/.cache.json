{"_id":"flow-engine","_rev":"56-c8893368619f7ca675423f9a49131975","name":"flow-engine","description":"A flow engine that is used to execute a series of tasks/policies","dist-tags":{"latest":"1.1.0"},"versions":{"1.0.1":{"name":"flow-engine","version":"1.0.1","description":"A flow engine that is used to executed a series of tasks/policies","main":"index.js","scripts":{"pretest":"jshint .","test":"mocha"},"repository":{"type":"git","url":"git@github.ibm.com:apimesh/flow-engine.git"},"keywords":["ibm","api","connect","apiconnect","gateway","flow","flowengine"],"author":{"name":"IBM"},"license":"SEE LICENSE IN LICENSE.txt","dependencies":{"async":"^1.5.2","bunyan":"^1.7.0","yamljs":"^0.2.4"},"devDependencies":{"express":"^4.13.0","http-auth":"^2.2.8","jshint":"^2.8.0","mocha":"^2.2.5","should":"^8.0.0","supertest":"^1.0.1"},"gitHead":"a1419caa10699294b6c88806c81b898328a42726","_id":"flow-engine@1.0.1","_shasum":"f0b76e64a42a032b6a69c88a5e2403c01d11d69d","_from":".","_npmVersion":"3.7.2","_nodeVersion":"4.2.6","_npmUser":{"name":"tjsmith.us.ibm.com","email":"tjsmith@us.ibm.com"},"dist":{"shasum":"f0b76e64a42a032b6a69c88a5e2403c01d11d69d","tarball":"https://registry.npmjs.org/flow-engine/-/flow-engine-1.0.1.tgz"},"maintainers":[{"name":"tjsmith.us.ibm.com","email":"tjsmith@us.ibm.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/flow-engine-1.0.1.tgz_1458583250962_0.5530391652137041"},"directories":{}},"1.0.3":{"name":"flow-engine","version":"1.0.3","description":"A flow engine that is used to execute a series of tasks/policies","main":"index.js","scripts":{"pretest":"eslint .","test":"mocha"},"repository":{"type":"git","url":"git@github.ibm.com:apimesh/flow-engine.git"},"keywords":["ibm","api","connect","apiconnect","gateway","flow","flowengine"],"author":{"name":"IBM"},"license":"SEE LICENSE IN LICENSE.txt","dependencies":{"async":"^1.5.2","bunyan":"^1.7.0","yamljs":"^0.2.4"},"devDependencies":{"eslint":"^2.8.0","express":"^4.13.0","http-auth":"^2.2.8","mocha":"^2.2.5","should":"^8.0.0","supertest":"^1.0.1"},"_id":"flow-engine@1.0.3","_shasum":"b7694dc29dae407aa5e4eee43f26b9f37f99d336","_resolved":"file:.strong-registry/rel.cache/flow-engine/1.0.3/package.tgz","_from":".strong-registry/rel.cache/flow-engine/1.0.3/package.tgz","_npmVersion":"3.8.7","_nodeVersion":"4.3.2","_npmUser":{"name":"kraman","email":"kraman@gmail.com"},"dist":{"shasum":"b7694dc29dae407aa5e4eee43f26b9f37f99d336","tarball":"https://registry.npmjs.org/flow-engine/-/flow-engine-1.0.3.tgz"},"maintainers":[{"name":"bajtos","email":"mbajtoss@gmail.com"},{"name":"chandadharap","email":"chanda_dharap@yahoo.com"},{"name":"ibmcloud-admin","email":"rmg@ca.ibm.com"},{"name":"jtary","email":"joseph.tary@gmail.com"},{"name":"kraman","email":"kraman@strongloop.com"},{"name":"octet","email":"vieuxtech@gmail.com"},{"name":"qpresley","email":"qpresley@ca.ibm.com"},{"name":"rfeng","email":"enjoyjava@gmail.com"},{"name":"ritch","email":"skawful@gmail.com"},{"name":"rmg","email":"r.m.graham@gmail.com"},{"name":"setogit","email":"setogit@gmail.com"},{"name":"tjsmith.us.ibm.com","email":"tjsmith@us.ibm.com"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/flow-engine-1.0.3.tgz_1462581097256_0.32807804783806205"},"directories":{}},"1.1.0":{"name":"flow-engine","version":"1.1.0","description":"A flow engine that is used to execute a series of tasks/policies","main":"index.js","scripts":{},"repository":{"type":"git","url":"git@github.ibm.com:apimesh/flow-engine.git"},"keywords":["ibm","api","connect","apiconnect","gateway","flow","flowengine"],"author":{"name":"IBM"},"license":"SEE LICENSE IN LICENSE.txt","dependencies":{"async":"^1.5.2","bunyan":"^1.7.0","yamljs":"^0.2.4"},"devDependencies":{"eslint":"^2.8.0","express":"^4.13.0","http-auth":"^2.2.8","mocha":"^2.2.5","should":"^8.0.0","supertest":"^1.0.1"},"_id":"flow-engine@1.1.0","_shasum":"5948264aff5ba7d8258dbeb882002936b2bcb254","_resolved":"file:../.strong-registry/rel.cache/flow-engine/1.1.0/package.tgz","_from":"../.strong-registry/rel.cache/flow-engine/1.1.0/package.tgz","_npmVersion":"3.9.5","_nodeVersion":"6.2.2","_npmUser":{"name":"kraman","email":"kraman@gmail.com"},"dist":{"shasum":"5948264aff5ba7d8258dbeb882002936b2bcb254","tarball":"https://registry.npmjs.org/flow-engine/-/flow-engine-1.1.0.tgz"},"maintainers":[{"name":"bajtos","email":"mbajtoss@gmail.com"},{"name":"behajian","email":"b.hajian@gmail.com"},{"name":"chandadharap","email":"chanda_dharap@yahoo.com"},{"name":"ibmcloud-admin","email":"rmg@ca.ibm.com"},{"name":"jtary","email":"joseph.tary@gmail.com"},{"name":"kjdelisle","email":"kjdelisle@gmail.com"},{"name":"kraman","email":"kraman@gmail.com"},{"name":"octet","email":"vieuxtech@gmail.com"},{"name":"pthieu","email":"pthieu@gmail.com"},{"name":"qpresley","email":"qpresley@ca.ibm.com"},{"name":"rfeng","email":"enjoyjava@gmail.com"},{"name":"ritch","email":"skawful@gmail.com"},{"name":"rmg","email":"r.m.graham@gmail.com"},{"name":"setogit","email":"setogit@gmail.com"},{"name":"tjsmith.us.ibm.com","email":"tjsmith@us.ibm.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/flow-engine-1.1.0.tgz_1470701897626_0.08181521412916481"},"directories":{}}},"readme":"# flow-engine\n\nThe flow-engine is a node.js module specializing in processing of a sequence of\ntasks. The tasks execution sequence is defined in JSON object's `assembly`\nproperty and passed to flow-engine for execution.\nIn The following example, flow-engine executes three tasks - `if`, `if`, and\n`response`. \n\n```\n{\n  \"assembly\": {\n    \"execute\": [\n      {\n        \"if\": {\n          \"condition\": \"'$(request.verb)' === 'POST'\",\n          \"execute\": [\n            {\n              \"message-mediation\": {\n                \"target\": \"context.response\",\n                \"value\": \"{ status: 200, message: 'This is a POST response' }\"\n              }\n            }\n          ]\n        }\n      },\n      {\n        \"if\": {\n          \"condition\": \"'$(request.verb)' === 'GET'\",\n          \"execute\": [\n            {\n              \"message-mediation\": {\n                \"target\": \"context.response\",\n                \"value\": \"{ status: 200, message: 'This is a GET response' }\"\n              }\n            }\n          ]\n        }\n      },\n      {\n        \"response\": {\n          \"payload\": \"context.response\"\n        }\n      }\n    ]\n  }\n}\n```\n\nEach task is a JavaScript function that can\n  - execute any code\n  - make change to the `context` object\n  - instruct flow-engine to continue or stop the remaining tasks execution\n\nThe flow-engine provides some prebuilt tasks at [lib/task](lib/task).\nYou can use these prebuilt tasks to compose your flow or use them as references\nto build customized ones. Putting the customized tasks to the `lib/task`\ndirectory, and flow-engine can pick up the new tasks without additional\nconfiguration.\n\n# flow-engine and IBM apiconnect-microgateway\nThe flow-engine is designed to be the heart of a gateway or reverse proxy.\nIt is included and used as part of the apiconnect-microgateway module that\nserves as API policies enforcement point.\n\nEach API policy on the apiconnect-microgateway is implemented as a flow-engine\ntask. And what and when API policies need to be enforced is describe as the\nassembly flow to be executed by the flow-engine.\n\n#Installation\n`npm install flow-engine`\n\n#APIs\nTo use the FlowEngine, one must `require('flow-engine')`.\n\n- setup function `require('flow-engine')(configObj)`:  \n  configObj supports the follow options:\n  - flow : the flow definition file and it shall be a YAML file\n  - paramResolver: a module's **location** that is used to resolve the\n    placeholder inside the flow assembly\n  - tasks: an object that contains all custom task modules' name and\n    **location**\n  - baseDir: the base directory that will be used to load modules\n\n  and the return value is a middleware handler\n  \n- `Flow(assembly, optionObj)`:  \n  Create a flow instance with the flow assembly\n  - assembly: the flow's assembly and it's JSON object\n  - optionObj: supports the following options:\n    - paramResolver: a function that is used to resolve the placeholder inside\n      the flow assembly\n    - tasks: an object that contains all custom task modules' name and their\n      handler functions. Use this option to control the creation/lifecycle of\n      task handlers by yourself. \n    - tid: transaction id. if it doesn't present, flow-engine uses tid() to get\n      tid that is maintained in flow-engine's scope.\n    - logger: a bunyan logger obj that flow-engine uses it for logging. if it\n      doesn't present, flow-engine creates its own logger.\n    - logLevel: flow-engine uses it to create its own logger if `logger` is not\n       there.\n\n- `Flow.prototype.prepare(context, next)`:  \n   Pass the `context` object and `next` function to the flow instance that you\n   create by the Flow ctor\n\n- `Flow.prototype.run()`:    \n   Start to execute the flow assembly\n\n- `Flow.prototype.subscribe(event, handler)`:    \n   Subscribe an event with an event handler. \n   - event: 'START', 'FINISH', 'ERROR' or 'pre|post:task-name'\n   - handler: a handler should be:  \n     `function(event, next)`  \n     A handler function would get the event name and a done callback(`next`). \n     The handler must call `next()` when it finishes.\n\n- `Flow.prototype.unsubscribe(event, handler)`:    \n   Remove the handler from the event's subscriber list\n\n- `tid()`:    \n   get a flow-engine scope transaction Id. Basically, it's a global counter\n   that start with 1 and increase 1 by each call.\n\nTo execute a flow described in YAML:\n\n```\nvar flow = require('flow-engine')({ config: \"flow.yaml\" });\n//the flow is a middleware handler and ready to be used\n\n```\n\nOr directly create a Flow instance with a specific JSON config\n```\nconst Flow = require('flow-engine').Flow;\nvar flow = new Flow( json, optionObj );\n//you have to manually pass the context and next into the flow and execute it\n//get context obj from somewhere or create it by yourself\n//and request and response object should be attached to the context obj\nflow.prepare(context, next);\nflow.run();\n```\n\n#APIs for Task/Policy developer\nA task is the unit of the flow assembly. flow-engine leverages tasks to fulfill\na flow assembly. When developing a custom task, flow-engine provides the\nfollowing APIs:\n\n- `invoke(assembly, options, next)`:  \n  flow-engine runs the given `assembly`. When the assembly finishes. the `next`\n  callback will be invoked. the `options` here is the same as the options in\n  `Flow(assembly, optionObj)`\n  - assembly: the flow's assembly and it's JSON object\n  - next: this callback will be invoked after the assembly finishes\n  - options: supports the following options:\n    - paramResolver: a function that is used to resolve the placeholder inside\n      the flow assembly\n    - tasks: an object that contains all custom task modules' name and handler\n      function\n    If these properties don't exist, the parent's will be used.\n- `subscribe(event, handler)`:    \n   Subscribe an event with an event handler. \n   - event: 'START', 'FINISH', 'ERROR' or 'pre|post:task-name'.\n   - handler: a handler should be:  \n     `function(event, next)`  \n     A handler function would get the event name and a done callback(`next`).\n     The handler must call `next()` when it finishes.\n\n- `unsubscribe(event, handler)`:    \n   Remove the handler from the event's subscriber list\n\n- `proceed()`:    \n   When a task finishes its job, it must call this API to tell flow-engine to\n   run the next task.\n\n- `fail(error)`:    \n   When a task finishes its job with error situation, it must call this API to\n   tell flow-engine to run the Error handing to process the error.\n\n- `stop()`:    \n   When a task finishes its job and the flow should also end, it must call this\n   API to tell flow-engine to finish the assembly execution.\n\n- `logger`:    \n   A bunyan logger object which is used for logging.\n\nThese APIs are attached to the third param of task handler interface and could\nbe used by task developer. Here is a simple task implementation:\n\n```\n'use strict';\n\nmodule.exports = function ( config ) {\n\n    return function (props, context, flow) {\n        var logger = flow.logger;\n        logger.info('ENTER mypolicy, params:', JSON.stringify(props));\n        //some business logic\n        \n        //and register a FINISH event handler\n        flow.subscribe('FINISH', function(event, next) {\n            //this would be executed when a flow finishes\n            next();\n        });\n        \n        //call next task\n        flow.proceed();\n    };\n};\n```\n\n#Sample\nUse the setup function to create a flow-engine middleware and register this\nmiddleware to handle all of the requests:\n```\nvar createFlow = require('flow-engine');\n\nvar flow = createFlow({\n        flow: \"flow.yaml\",\n        tasks: {'activity-log': './myactivity-log.js'},\n        baseDir: __dirname});\n\nvar app = express();\napp.post('/*', [ flow ]);\n\n```\n\n#The Design\n### The middleware interface\n- The interface is `function(request, response, next)`\n- The flow-engine module supports the middleware interface. It returns the\n  middleware handler:\n\n  ```\n  var middlewareHandler = require('flow-engine')(some_config);\n  middlewareHandler(request, response, next);\n  ```\n\n### The Task/Policy interface\n- Every task that is defined inside the assembly should have a corresponding\n  task module.And the task module should provide a factory function - \n  `function(config)` and return a task handler function - \n  `function(props, context, flow)`. Therefore, flow-engine will use the task\n  module like this:\n\n  ```\n  var taskHandler = require('taskModule')(task_config);\n  taskHandler(props, context, flow);\n  ```\n  \n- **Finding task/policy handlers to execute the tasks/policies that defined in\n  the assembly**:\n  - tasks under `<flow-engine>/lib/task` are loaded when require('flow-engine').\n    flow-engine calls these tasks' factory functions with empty config object\n    and keeps the returned task handler functions\n  - use task's name to search the task module and see if there is a task module\n    under options.tasks[taskName].\n    The options.tasks here is the options that you pass to Flow's constructor or\n    the setup function.\n    The difference is the options.tasks that you pass to the setup function will\n    be processed via the `require()`, call its factory function by passing empty\n    config object and get the task handler function. And the options.tasks that\n    you pass to Flow's constructor function shall be task handler functions\n    already.\n  - searching the task module under `<flow-engine>/lib/task.\n  - directly use `require` against the task's name, call its factory function\n    with empty config and get the handler function\n\n- **Execute a task/policy**:\n  - use the `Finding task handlers procedure` above to get task's handler\n    function\n  - get the properties/values that defined in the assemble for the task and use\n    paramResolver to replace the placeholder into corresponding value if exists\n  - call the task handler function we get from step 1 and pass the\n    properties/values, context obj and flow obj into it. the `flow` here is an\n    object which contains a set of APIs:\n    - .proceed(): when a task finishes its job successfully, it must call this\n      function to tell flow-engine that its job is done, please continue with\n      next task\n    - .fail(error): when a task couldn't finish it job, it must call this\n      function to tell flow-engine that an error is found and ask flow-engine\n      to handle the error. flow-engine will perform the `Error Handling`\n      procedure then.\n    - .subscribe(event, cb): a task could subscribe some specific events.\n      flow-engine would invoke the `cb` when the specific events are triggered.\n      The `cb` shall be a `function(event, next)`. Inside the callback, next()\n      must be called when the callback finishes. Currently, the following events\n      are supported:\n      - FINISH: a flow finishes. flow-engine finishes an assembly execution\n      - ERROR: an error is threw from an assembly execution\n      - pre|post:taskName: before or after a task's execution\n    - .unsubscribe(event, cb): unsubscribe an event\n    - .logger: a bunyan logger object and could be used for logging\n  - if the task finishes without any error, then the flow engine goes to the\n    next task\n\n- **Error Handling**:\n  - check if there is local error handling for the task:\n    - if yes, then execute the tasks defined in the error handling:\n      - when the local error handling finishes and the local handling throws\n        another error, then go to global error handling\n      - then the flow ends\n    - if no, then see if there is any global error handling:\n      - no global error handling : use default error handling and then ends the\n        flow\n      - global error handling exists: execute the global error handling and then\n        ends the flow\n\n### Event\nflow-engine supports observable interface and provides `subscribe()` and\n`unsubscribe()` APIs. Currently, the following events are supported:\n\n- START: flow-engine starts to execute an assembly and none of the policy is\n  executed yet\n- FINISH: all of the policies in an assembly are executed successfully\n- ERROR: the flow execution ends with an error\n- 'pre|post:task-name': before or after the execution of a task/policy.\n  The post event is **only** triggered when a task/policy finishes without any\n  error, even if the 'catch' clause recovers the error.\n\nIn order to keep the flow execution is clean, any error that is thrown/created\nby an event handler would only be logged and then ignored. Therefore, an event\nhandler wouldn't impact the flow execution as well as other event handlers.\n\nYou can access the `subscribe()` and `unsubscribe()` from a Flow instance if\nyou use the Flow ctor to create a flow instance. In side a task, the third\nparam of the task handler function is an flow object which contains\n`subscribe()` and `unsubscribe()` APIs.\n\n### The `context` object\nThe `context` object should be created before the flow-engine, probably by\nusing a context middleware before the flow-engine middleware. flow-engine uses\nthe `context` object as one of the arguments when invoking every task function.\nA task could access `context` object, including retrieving and populating\nproperties. When flow-engine finishes, all the information should be stored into\nthe `context` object. Having a middleware after the flow-engine middleware is a\ntypical approach to produce the output content and maybe flush/write to the\nresponse object at the same time. \n\nCurrently, flow-engine provides a context module in `./lib/context` which could\nbe used to create the context object. It provides the following APIs:\n- createContext([namespace]):  \n  create a context object with the specified namespace. namespace is optional.\n\n- The context object provides getter, setter and dot notation to access its\n  variables:\n  - get(name):  \n    get the variable by name.\n\n  - set(name, value[, readOnly]):    \n    add or update a variable with the specified name and value. default value\n    of readOnly is 'false'.\n    Use readonly=true to add read-only variable.  \n    Note: updating a read-only variable will cause the exception.\n\n  - define(name, getter[,setter, configurable]):\n    - `name`: variable name\n    - `getter`: getter function\n    - `setter`: setter function\n    - `configurable`: allow re-define or not. (true|false)\n\n    add or update a variable with the specified getter, setter and configurable.\n    Use configurable=false to avoid variable re-define.  \n    Note: set new value to a getter-only variable will cause the exception.\n\n  - del(name):  \n    delete the variable by name.\n\n  - subscribe(event, handler):  \n    subscribe an event with the handler function : `function(event, next)`.\n\n  - unsubscribe(event, handler):  \n    unsubscribe the event\n\n  - notify(event, callback):  \n    fire the event and all of the handlers are invoked sequentially (based on\n    the registration sequence). Then `callback` is called with undefined or an\n    array of errors that subscriber handlers return.\n\n  - dot notation:  \n    You can also use dot notation to access the variables of a context object.\n```javascript\n        //If a context is created with a namespace - 'fool',\n        //you can access its variables like this:    \n        var ctx1 = require('./lib/context').createContext('fool');\n        ctx1.set('myvar', 'value');\n        ctx1.fool.myvar === 'value';\n        ctx1.fool.myvar = 'new-value';\n        ctx1.get('myvar') === 'new-value';\n        //\n        //If there is no namespace, then all of the variables are\n        //directly attached to the context object:\n        var ctx2 = require('./lib/context').createContext();\n        ctx2.set('myvar', 'value');\n        ctx2.myvar === 'value';\n        ctx2.myvar = 'new-value';\n        ctx2.get('myvar') === 'new-value';\n```\n","maintainers":[{"name":"bajtos","email":"mbajtoss@gmail.com"},{"name":"behajian","email":"b.hajian@gmail.com"},{"name":"chandadharap","email":"chanda_dharap@yahoo.com"},{"name":"ibmcloud-admin","email":"rmg@ca.ibm.com"},{"name":"jtary","email":"joseph.tary@gmail.com"},{"name":"kjdelisle","email":"kjdelisle@gmail.com"},{"name":"kraman","email":"kraman@gmail.com"},{"name":"octet","email":"vieuxtech@gmail.com"},{"name":"pthieu","email":"pthieu@gmail.com"},{"name":"qpresley","email":"qpresley@ca.ibm.com"},{"name":"rfeng","email":"enjoyjava@gmail.com"},{"name":"ritch","email":"skawful@gmail.com"},{"name":"rmg","email":"r.m.graham@gmail.com"},{"name":"setogit","email":"setogit@gmail.com"},{"name":"tjsmith.us.ibm.com","email":"tjsmith@us.ibm.com"}],"time":{"modified":"2016-09-23T00:09:13.259Z","created":"2016-03-21T18:00:54.259Z","1.0.1":"2016-03-21T18:00:54.259Z","1.0.3":"2016-05-07T00:31:38.868Z","1.1.0":"2016-08-09T00:18:17.877Z"},"keywords":["ibm","api","connect","apiconnect","gateway","flow","flowengine"],"repository":{"type":"git","url":"git@github.ibm.com:apimesh/flow-engine.git"},"author":{"name":"IBM"},"license":"SEE LICENSE IN LICENSE.txt","readmeFilename":"README.md","_attachments":{},"_etag":"\"F4VC3HG9HKFDZCXFOC9TU78H3\"","_cached":true}